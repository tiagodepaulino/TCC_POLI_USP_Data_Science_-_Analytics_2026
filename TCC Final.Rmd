---
title: "TCC Final"
author: "Tiago Paulino"
date: "2025-11-02"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
options(repos = c(CRAN = "https://cloud.r-project.org"))
knitr::opts_chunk$set(echo = TRUE)
```

## Instalando as bibliotecas

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

install.packages("readxl", "dplyr","tidyr", "stringr", "car", "ggplot2")
install.packages("psych")
install.packages("plotly")
install.packages("corrplot")
install.packages("car")
install.packages("reshape2")
install.packages("purrr")
install.packages("patchwork")

```

## Carregando os Pacotes

```{r message=FALSE, warning=FALSE, paged.print=FALSE}

library(readxl)
library(dplyr)
library(tidyr)
library(stringr)
library(psych)
library(ggplot2)
library(plotly)
library(corrplot)
library(car)
library(reshape2)
library(purrr)

```

## Importando o Dataframe de preços de Topload, Fogão e Refrigerador Topfreezer

```{r}

df <- read_excel("C:/Users/USER/OneDrive/Documentos/TCC/Resultados Premiliminares - R/dataframe.xlsx")

```

## Prévia do Dataframe

```{r}

head(df)

```

```{r}

df_long <- pivot_longer(
  df,
  cols = -Período,
  names_to = "Variavel",
  values_to = "Valor"
)

# Definindo a ordem das variáveis para garantir 5 em cada linha
# (A ordem que as variáveis aparecem no dataframe long será a ordem de plotagem)
ordem_variaveis <- c("Dolar", "ICC", "ICC (Expectativas)",
                     "ICC (Situação Presente)", "IPP", "Massa Salarial",
                     "Selic", "Topload", "Fogão", "Topfreezer")

df_long$Variavel <- factor(df_long$Variavel, levels = ordem_variaveis)

# Criação do gráfico
ggplot(df_long, aes(x = Período, y = Valor)) +
  geom_line(color = "steelblue", size = 0.8) +  
  
  facet_wrap(~Variavel, scales = "free_y", nrow = 2) +
  
  labs(title = "Série Temporal das Variáveis",
       x = "Período", y = "Valor") +
  
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title.x = element_text(face = "bold"),
    axis.title.y = element_text(face = "bold"),

strip.background = element_rect(fill = "gray90", color = "black"),
    strip.text = element_text(face = "bold"),
    
    axis.text.x = element_text(size = 8) 
  ) + NULL
    
```

## Padronizando as variáveis com método Z-Score

```{r}

df_z <- df
cols_para_padronizar <- setdiff(names(df), c("Período", "Topload", 
                                             "Fogão", "Topfreezer"))
df_z[ , cols_para_padronizar] <- scale(df[ , cols_para_padronizar])
head(df_z)
summary(df_z)

```

## Visualizando a série temporal das variáveis padronizadas

```{r}

df_long_z <- pivot_longer(
  df_z,
  cols = -Período,
  names_to = "Variavel",
  values_to = "Valor"
)

ordem_variaveis <- c("Dolar", "ICC", "ICC (Expectativas)",
                     "ICC (Situação Presente)",
                     "IPP", "Massa Salarial", "Selic", "Topload",
                     "Fogão", "Topfreezer")

df_long_z$Variavel <- factor(df_long_z$Variavel, levels = ordem_variaveis)

ggplot(df_long_z, aes(x = Período, y = Valor)) +
  geom_line(color = "steelblue", size = 0.8) +
  
  facet_wrap(~Variavel, scales = "free_y", nrow = 2) +
  
  labs(title = "Série Temporal das Variáveis",
       x = "Período", y = "Valor") +
  
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title.x = element_text(face = "bold"),
    axis.title.y = element_text(face = "bold"),

strip.background = element_rect(fill = "gray90", color = "black"),
    strip.text = element_text(face = "bold"),
    
    axis.text.x = element_text(size = 8) 
  ) + NULL
    

```

## Criando uma variável dummy "Sazonalidade", para os mêses de Janeiro e Novembro; período cíclico onde é esperado um vale no preço médio da categoria.

```{r}


df_z$Sazonalidade <- ifelse(format(df$Período, "%m") %in% c("01", "11"), 1, 0)
head(df_z)

```

## Correlacionando as variáveis para selecionar aquelas com principal poder explicativo e identificar possíveis multicolinearidades

```{r}

# --- 1. Definição de Variáveis ---
variaveis_dependentes <- c("Topload", "Fogão", "Topfreezer")
variaveis_independentes <- c("Selic", "IPP", "ICC", 
                             "ICC (Expectativas)", "ICC (Situação Presente)",
                             "Dolar", "Sazonalidade", "Massa Salarial")

# --- 2. Calculo da Matriz de Correlação Completa ---
df_cor <- df_z %>%
  select(all_of(variaveis_dependentes), all_of(variaveis_independentes))

# Calcular a matriz de correlação
matriz_cor <- cor(df_cor, use = "pairwise.complete.obs")

# --- 3. Extrai e Reformata as Correlações Relevantes ---

# (Variáveis Dependentes vs Variáveis Independentes)
cor_df <- matriz_cor[variaveis_independentes, variaveis_dependentes, drop = FALSE]

cor_long <- cor_df %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "Variavel_Independente") %>%
  pivot_longer(
    cols = all_of(variaveis_dependentes),
    names_to = "Variavel_Dependente",
    values_to = "Correlacao"
  )

cor_long$Variavel_Dependente <- factor(
  cor_long$Variavel_Dependente,
  levels = variaveis_dependentes
)

cor_long$Variavel_Independente <- factor(
  cor_long$Variavel_Independente,
  levels = rev(variaveis_independentes)
)


# --- 4. Criação da Visualização com ggplot2 ---

ggplot(cor_long, aes(x = 1, y = Variavel_Independente, fill = Correlacao)) +
  
  # Mapa de Calor (Tile)
  geom_tile(color = "white") +
  
  # Valores da Correlação como Texto
  geom_text(aes(label = sprintf("%.2f", Correlacao)), color = "black", size = 4) +
  
  scale_fill_gradient2(
    low = "#BC5449",     # Vermelho/Marrom para negativo
    mid = "white",      # Branco para perto de zero
    high = "#0047AB",    # Azul Escuro para positivo
    midpoint = 0,       # Ponto médio em zero
    limit = c(-1, 1),   # Limites fixos de -1 a 1
    space = "Lab",
    name = "Correlação"
  ) +
  
  # Configurações do Layout para Gráficos Paralelos
  facet_wrap(~ Variavel_Dependente, ncol = 3) +
  
  # Remover eixos desnecessários e ajustar o tema
  labs(
    x = "",
    y = ""
  ) +
  scale_x_continuous(breaks = NULL) + # Remove os ticks e labels do eixo X
  theme_minimal() +
  theme(
    # Ajustes de texto
    axis.text.x = element_blank(),
    axis.text.y = element_text(angle = 0, hjust = 1, size = 10),
    # Ajustes do painel e grade
    panel.grid.major = element_blank(),
    panel.border = element_blank(),
    # Títulos do Facet
    strip.text = element_text(face = "bold", size = 12)
  )

```

## Verificar multicolinearidade ou alta correlação entre variáveis independentes

## Aplicação do VIF (Variance Inflation Factor)

```{r}

#Criação de um modelo preliminar com as variáveis mais correlacionadas

modelo_vif_tl <- lm(df_z$Topload ~ df_z$Selic + df_z$IPP +
                      df_z$`Massa Salarial` + df_z$`ICC (Expectativas)` +
                      df_z$Sazonalidade)

modelo_vif_fg <- lm(df_z$Fogão ~ df_z$Selic + df_z$IPP +
                      df_z$`Massa Salarial` + df_z$ICC +
                      df_z$Sazonalidade)

modelo_vif_tf <- lm(df_z$Topfreezer ~ df_z$Selic + df_z$IPP +
                      df_z$`Massa Salarial` + df_z$ICC +
                      df_z$Sazonalidade)

# --- 2. Calcular VIFs e Consolidar os Dados ---

# Função auxiliar para calcular VIF e formatar em um dataframe
calcular_vif_df <- function(modelo, nome_dependente) {
  vif_valores <- car::vif(modelo)
  
  # Cria um dataframe com os resultados
  df_resultado <- data.frame(
    Variavel_Dependente = nome_dependente,
    Variavel_Independente = names(vif_valores),
    VIF = as.numeric(vif_valores)
  )
  return(df_resultado)
}

# Calcular e combinar os VIFs de todos os modelos
df_vif_final <- bind_rows(
  calcular_vif_df(modelo_vif_tl, "Topload"),
  calcular_vif_df(modelo_vif_fg, "Fogão"),
  calcular_vif_df(modelo_vif_tf, "Topfreezer")
)

# --- 3. Criar a Visualização com ggplot2 ---

# Definir o limite de VIF (o valor 5 é um limite comum de atenção)
VIF_LIMITE <- 5

ggplot(df_vif_final, aes(x = VIF, y = Variavel_Independente, fill = VIF)) +
  
  # Gráfico de Barras Horizontal
  geom_bar(stat = "identity") +
  
  # Linha de Referência para o limite de multicolinearidade (VIF > 5)
  geom_vline(
    xintercept = VIF_LIMITE, 
    linetype = "dashed", 
    color = "red", 
    size = 1
  ) +
  
  # Texto no gráfico para indicar a linha de limite
  annotate("text", 
           x = VIF_LIMITE + 0.5, y = Inf, 
           label = "", 
           color = "red", 
           hjust = 0, vjust = 1.5, 
           size = 3.5, fontface = "bold") +
  
  # Escala de Cor (para colorir as barras com base no valor VIF)
  scale_fill_gradient(low = "#2ECC71", high = "#E74C3C",
                      limits = c(0, max(c(df_vif_final$VIF, VIF_LIMITE)))) +
  
  # Dividir em painéis (facetas) por Variável Dependente
  facet_wrap(~ Variavel_Dependente, ncol = 3, scales = "free_y") +
  
  # Títulos e Rótulos
  labs(
    title = "Análise de Multicolinearidade (VIF)",
    subtitle = "Linha pontilhada vermelha indica VIF = 5 (limite de atenção)",
    x = "Valor do VIF (Variance Inflation Factor)",
    y = "Variável Independente",
    fill = "VIF"
  ) +
  
  # Tema para Estilização
  theme_minimal() +
  theme(
    legend.position = "none", # A legenda de cor é redundante com a barra
    plot.title = element_text(face = "bold", hjust = 0.5),
    strip.text = element_text(face = "bold", size = 11) # Títulos dos Facets
  )

```

## 1 \< VIF \< 5 indica problema de multicolinearidade modearada.

## Portanto, existe correlação entre as variáveis, mas não de forma grave.

## Próximo passo é verificar a distribuição dos resíduos.

-   Comportamento aleatório
-   Heterocedasticidade (resíduos com variância desigual)
-   Distribuição aproximadamente normal

## Topload

```{r}

modelo_tl <- lm(df_z$Topload ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial`
                + df_z$`ICC (Expectativas)` + df_z$Sazonalidade)

# Resumo
summary(modelo_tl)

# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_tl)

```

## Massa Salarial não contribui para o modelo e pode ser removida.

```{r}

modelo_tl_2 <- lm(df_z$Topload ~ df_z$Selic + df_z$IPP +
                    df_z$`ICC (Expectativas)` + df_z$Sazonalidade)

# Resumo
summary(modelo_tl_2)

# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_tl_2)

```

## Fogão

```{r}

modelo_fg <- lm(df_z$Fogão ~ df_z$Selic + df_z$IPP +
                  df_z$`Massa Salarial` + df_z$ICC + df_z$Sazonalidade)

# Resumo
summary(modelo_fg)

# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_fg)

```

## Selic, ICC e Sazonalidade não contribuem para o modelo e podem ser removidos.

```{r}

modelo_fg_2 <- lm(df_z$Fogão ~ df_z$IPP + df_z$`Massa Salarial`)

# Resumo
summary(modelo_fg_2)

# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_fg_2)

```

## Topfreezer

```{r}

modelo_tf <- lm(df_z$Topfreezer ~ df_z$Selic + df_z$IPP +
                  df_z$`Massa Salarial` + df_z$ICC + df_z$Sazonalidade)

# Resumo
summary(modelo_tf)

# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_tf)

```

## Massa Salarial, ICC e Sazonalidade não contribuem para o modelo e podem ser removidos

```{r}

modelo_tf_2 <- lm(df_z$Topfreezer ~ df_z$Selic + df_z$IPP)

# Resumo
summary(modelo_tf_2)

# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_tf_2)

```

## Por fim, para avaliar a performance do modelo, irei dividir a base entre "Treino" e "Teste".
## Cálculo de métricas de performance:

-   Erro Quadrático Médio (RMSE);
-   Erro Médio
-   R²

```{r}

# --- 1. Preparação dos Dados (Split Treino/Teste) ---

set.seed(123)
n <- nrow(df_z)
indices_treino <- sample(1:n, size = round(2/3 * n))
treino <- df_z[indices_treino, ]
teste <- df_z[-indices_treino, ]

# --- 2. Definição dos Modelos a serem Avaliados ---

modelos_a_avaliar <- list(
  Topload = Topload ~ Selic + IPP + `ICC (Expectativas)` + Sazonalidade,
  Fogao = Fogão ~ IPP + `Massa Salarial`,
  Topfreezer = Topfreezer ~ Selic + IPP
)

# --- 3. Função de Validação e Cálculo de Métricas (Core da Otimização) ---

validar_modelo <- function(formula, nome_modelo, dados_treino, dados_teste) {
  # 1. Treinar o modelo
  modelo_fit <- lm(formula, data = dados_treino)
  
  # 2. Prever nos dados de teste
  preds <- predict(modelo_fit, newdata = dados_teste)
  
  # Variável Real (Y)
  y_real <- dados_teste[[gsub(" .*", "", as.character(formula)[2])]]
  
  # 3. Calcular Métricas
  RMSE <- sqrt(mean((y_real - preds)^2, na.rm = TRUE))
  MAE <- mean(abs(y_real - preds), na.rm = TRUE)
  SS_res <- sum((y_real - preds)^2, na.rm = TRUE)
  SS_tot <- sum((y_real - mean(y_real, na.rm = TRUE))^2, na.rm = TRUE)
  R2 <- 1 - (SS_res / SS_tot)
  
  # 4. Retornar um dataframe com as métricas e os dados para o gráfico
  return(list(
    # Tabela de Métricas
    metrics = data.frame(
      Modelo = nome_modelo,
      RMSE = RMSE,
      MAE = MAE,
      R2 = R2
    ),
    # Dados para o Gráfico Predito vs Real
    plot_data = data.frame(
      Modelo = nome_modelo,
      Real = y_real,
      Predito = preds
    )
  ))
}

# --- 4. Executar a Validação Cruzada para todos os Modelos (Iteração) ---

# Usar 'map' para aplicar a função a cada modelo na lista
resultados_lista <- map(
  names(modelos_a_avaliar),
  ~ validar_modelo(
    formula = modelos_a_avaliar[[.x]], 
    nome_modelo = .x, 
    dados_treino = treino, 
    dados_teste = teste
  )
)

# --- 5. Consolidar os Outputs ---

# Reunir as tabelas de métricas em um dataframe único
tabela_metricas <- map_dfr(resultados_lista, "metrics")

# Reunir os dados de plotagem para um gráfico facetado
df_plot_final <- map_dfr(resultados_lista, "plot_data")


# ----------------------------------------------------------------------
# -------------------- OTIMIZAÇÃO DA VISUALIZAÇÃO ----------------------
# ----------------------------------------------------------------------

## 1. TABELA DE MÉTRICAS CONSOLIDADAS

cat("=========================================================\n")
cat("          METRICAS DE PERFORMANCE EM DADOS DE TESTE       \n")
cat("=========================================================\n")
print(tabela_metricas %>% 
        mutate(across(c(RMSE, MAE, R2), ~ round(.x, 4)))
)
cat("\n\n")

## 2. GRÁFICO DE PREDITO VS. REAL UNIFICADO

# Criar o gráfico base usando facet_wrap para os 3 modelos
grafico_final_cv <- ggplot(df_plot_final, aes(x = Real, y = Predito)) +
  
  # Pontos
  geom_point(aes(color = Modelo), alpha = 0.7) +
  
  # Linha de tendência (opcional, mostra o ajuste do modelo)
  geom_smooth(method = "lm", se = FALSE, color = "blue", linewidth = 0.5) +
  
  # Dividir o gráfico em 3 painéis (facets)
  facet_wrap(~ Modelo, scales = "free", ncol = 3) +
  
  # Adicionar o R² como anotação em cada painel
  geom_text(
    data = tabela_metricas,
    aes(
      label = paste0("R² = ", round(R2, 4)), 
      x = Inf, # Posição no canto superior direito do eixo X
      y = -Inf # Posição no canto superior direito do eixo Y (inverso para topo)
    ),
    hjust = 1.1, vjust = -1, # Ajustar posição para dentro da área de plotagem
    size = 4, fontface = "bold", color = "darkgreen"
  ) +
  
  # Títulos e Tema
  labs(
    title = "Valores Reais vs. Preditos (Validação Cruzada)",
    subtitle = "",
    x = "Valor Real (R$)",
    y = "Valor Predito (R$)"
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    strip.text = element_text(face = "bold", size = 10),
    legend.position = "none"
  )

# Exibir o gráfico final
print(grafico_final_cv)

```

options(repos = c(CRAN = "https://cloud.r-project.org"))
knitr::opts_chunk$set(echo = TRUE)
install.packages("readxl", "dplyr","tidyr", "stringr", "car", "ggplot2")
install.packages("psych")
install.packages("plotly")
install.packages("corrplot")
install.packages("car")
install.packages("reshape2")
install.packages("purrr")
install.packages("patchwork")
library(readxl)
library(dplyr)
library(tidyr)
library(stringr)
library(psych)
library(ggplot2)
library(plotly)
library(corrplot)
library(car)
library(reshape2)
df <- read_excel("C:/Users/USER/OneDrive/Documentos/TCC/Resultados Premiliminares - R/dataframe.xlsx")
head(df)
df_long <- pivot_longer(
df,
cols = -Período,
names_to = "Variavel",
values_to = "Valor"
)
# Definindo a ordem das variáveis para garantir 5 em cada linha
# (A ordem que as variáveis aparecem no dataframe long será a ordem de plotagem)
ordem_variaveis <- c("Dolar", "ICC", "ICC (Expectativas)", "ICC (Situação Presente)",
"IPP", "Massa Salarial", "Selic", "Topload", "Fogão", "Topfreezer")
df_long$Variavel <- factor(df_long$Variavel, levels = ordem_variaveis)
# Criação do gráfico com as melhorias
ggplot(df_long, aes(x = Período, y = Valor)) +
geom_line(color = "steelblue", size = 0.8) +  # Linha mais espessa
# Distribuição em 2 linhas (nrow = 2) e escalas de Y livres
facet_wrap(~Variavel, scales = "free_y", nrow = 2) +
labs(title = "Série Temporal das Variáveis",
x = "Período", y = "Valor") +
# Melhorias no Tema e Eixo X
theme_bw() + # Tema base mais limpo
theme(
plot.title = element_text(hjust = 0.5, face = "bold"), # Título centralizado e em negrito
axis.title.x = element_text(face = "bold"), # Nome do eixo X em negrito
axis.title.y = element_text(face = "bold"), # Nome do eixo Y em negrito
strip.background = element_rect(fill = "gray90", color = "black"),
strip.text = element_text(face = "bold"),
# Ajustando o texto do eixo X em geral para os painéis
axis.text.x = element_text(size = 8)
) + NULL
df_z <- df
cols_para_padronizar <- setdiff(names(df), c("Período", "Topload", "Fogão", "Topfreezer"))
df_z[ , cols_para_padronizar] <- scale(df[ , cols_para_padronizar])
head(df_z)
summary(df_z)
df_long_z <- pivot_longer(
df_z,
cols = -Período,
names_to = "Variavel",
values_to = "Valor"
)
# Definindo a ordem das variáveis para garantir 5 em cada linha
# (A ordem que as variáveis aparecem no dataframe long será a ordem de plotagem)
ordem_variaveis <- c("Dolar", "ICC", "ICC (Expectativas)", "ICC (Situação Presente)",
"IPP", "Massa Salarial", "Selic", "Topload", "Fogão", "Topfreezer")
df_long_z$Variavel <- factor(df_long_z$Variavel, levels = ordem_variaveis)
# Criação do gráfico com as melhorias
ggplot(df_long_z, aes(x = Período, y = Valor)) +
geom_line(color = "steelblue", size = 0.8) +  # Linha mais espessa
# Distribuição em 2 linhas (nrow = 2) e escalas de Y livres
facet_wrap(~Variavel, scales = "free_y", nrow = 2) +
labs(title = "Série Temporal das Variáveis",
x = "Período", y = "Valor") +
# Melhorias no Tema e Eixo X
theme_bw() + # Tema base mais limpo
theme(
plot.title = element_text(hjust = 0.5, face = "bold"), # Título centralizado e em negrito
axis.title.x = element_text(face = "bold"), # Nome do eixo X em negrito
axis.title.y = element_text(face = "bold"), # Nome do eixo Y em negrito
strip.background = element_rect(fill = "gray90", color = "black"),
strip.text = element_text(face = "bold"),
# Ajustando o texto do eixo X em geral para os painéis
axis.text.x = element_text(size = 8)
) + NULL
df_z$Sazonalidade <- ifelse(format(df$Período, "%m") %in% c("01", "11"), 1, 0)
head(df_z)
# --- 1. Definir Variáveis ---
# Assegure-se de que o dataframe df_z esteja carregado e contenha essas colunas
variaveis_dependentes <- c("Topload", "Fogão", "Topfreezer")
variaveis_independentes <- c("Selic", "IPP", "ICC", "ICC (Expectativas)", "ICC (Situação Presente)", "Dolar", "Sazonalidade", "Massa Salarial")
# --- 2. Calcular a Matriz de Correlação Completa ---
# Selecionar apenas as colunas de interesse
df_cor <- df_z %>%
select(all_of(variaveis_dependentes), all_of(variaveis_independentes))
# Calcular a matriz de correlação
matriz_cor <- cor(df_cor, use = "pairwise.complete.obs") # 'pairwise.complete.obs' lida com NAs, se existirem
# --- 3. Extrair e Reformatar as Correlações Relevantes ---
# Selecionar apenas as linhas/colunas da matriz de correlação que nos interessam
# (Variáveis Dependentes vs Variáveis Independentes)
cor_df <- matriz_cor[variaveis_independentes, variaveis_dependentes, drop = FALSE]
# Transformar para o formato "longo" usando reshape2::melt para o ggplot2
cor_long <- cor_df %>%
as.data.frame() %>%
tibble::rownames_to_column(var = "Variavel_Independente") %>%
pivot_longer(
cols = all_of(variaveis_dependentes),
names_to = "Variavel_Dependente",
values_to = "Correlacao"
)
# Ajustar a ordem da Variavel_Dependente para o facet (opcional, mas recomendado)
cor_long$Variavel_Dependente <- factor(
cor_long$Variavel_Dependente,
levels = variaveis_dependentes
)
# Ajustar a ordem da Variavel_Independente para a plotagem (opcional)
cor_long$Variavel_Independente <- factor(
cor_long$Variavel_Independente,
levels = rev(variaveis_independentes) # Invertendo para que o gráfico fique "de baixo para cima"
)
# --- 4. Criar a Visualização com ggplot2 ---
ggplot(cor_long, aes(x = 1, y = Variavel_Independente, fill = Correlacao)) +
# Mapa de Calor (Tile)
geom_tile(color = "white") +
# Valores da Correlação como Texto
geom_text(aes(label = sprintf("%.2f", Correlacao)), color = "black", size = 4) +
# Escala de Cor (semelhante à original: azul escuro para positivo, vermelho/claro para negativo/próximo de zero)
scale_fill_gradient2(
low = "#BC5449",     # Vermelho/Marrom para negativo
mid = "white",      # Branco para perto de zero
high = "#0047AB",    # Azul Escuro para positivo
midpoint = 0,       # Ponto médio em zero
limit = c(-1, 1),   # Limites fixos de -1 a 1
space = "Lab",
name = "Correlação"
) +
# Configurações do Layout para Gráficos Paralelos
facet_wrap(~ Variavel_Dependente, ncol = 3) +
# Remover eixos desnecessários e ajustar o tema
labs(
x = "", # O eixo X é apenas um placeholder para o mapa de calor
y = ""
) +
scale_x_continuous(breaks = NULL) + # Remove os ticks e labels do eixo X
theme_minimal() +
theme(
# Ajustes de texto
axis.text.x = element_blank(),
axis.text.y = element_text(angle = 0, hjust = 1, size = 10),
# Ajustes do painel e grade
panel.grid.major = element_blank(),
panel.border = element_blank(),
# Títulos do Facet
strip.text = element_text(face = "bold", size = 12)
)
# O resultado será um único gráfico com 3 painéis (facets), um para cada variável dependente.
# Cada painel mostrará a correlação daquela variável dependente com todas as independentes.
#Criação de um modelo preliminar com as variáveis mais correlacionadas
modelo_vif_tl <- lm(df_z$Topload ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$`ICC (Expectativas)` + df_z$Sazonalidade)
modelo_vif_fg <- lm(df_z$Fogão ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$ICC + df_z$Sazonalidade)
modelo_vif_tf <- lm(df_z$Topfreezer ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$ICC + df_z$Sazonalidade)
# --- 2. Calcular VIFs e Consolidar os Dados ---
# Função auxiliar para calcular VIF e formatar em um dataframe
calcular_vif_df <- function(modelo, nome_dependente) {
vif_valores <- car::vif(modelo)
# Cria um dataframe com os resultados
df_resultado <- data.frame(
Variavel_Dependente = nome_dependente,
Variavel_Independente = names(vif_valores),
VIF = as.numeric(vif_valores)
)
return(df_resultado)
}
# Calcular e combinar os VIFs de todos os modelos
df_vif_final <- bind_rows(
calcular_vif_df(modelo_vif_tl, "Topload"),
calcular_vif_df(modelo_vif_fg, "Fogão"),
calcular_vif_df(modelo_vif_tf, "Topfreezer")
)
# --- 3. Criar a Visualização com ggplot2 ---
# Definir o limite de VIF (o valor 5 é um limite comum de atenção)
VIF_LIMITE <- 5
ggplot(df_vif_final, aes(x = VIF, y = Variavel_Independente, fill = VIF)) +
# Gráfico de Barras Horizontal
geom_bar(stat = "identity") +
# Linha de Referência para o limite de multicolinearidade (VIF > 5)
geom_vline(
xintercept = VIF_LIMITE,
linetype = "dashed",
color = "red",
size = 1
) +
# Texto no gráfico para indicar a linha de limite
annotate("text",
x = VIF_LIMITE + 0.5, y = Inf,
label = paste("Limite VIF =", VIF_LIMITE),
color = "red",
hjust = 0, vjust = 1.5,
size = 3.5, fontface = "bold") +
# Escala de Cor (para colorir as barras com base no valor VIF)
scale_fill_gradient(low = "#2ECC71", high = "#E74C3C", # Verde para baixo, Vermelho para alto
limits = c(0, max(c(df_vif_final$VIF, VIF_LIMITE)))) +
# Dividir em painéis (facetas) por Variável Dependente
facet_wrap(~ Variavel_Dependente, ncol = 3, scales = "free_y") +
# Títulos e Rótulos
labs(
title = "Análise de Multicolinearidade (VIF) por Variável Dependente",
subtitle = "Linha pontilhada vermelha indica VIF = 5 (limite de atenção)",
x = "Valor do VIF (Variance Inflation Factor)",
y = "Variável Independente",
fill = "VIF"
) +
# Tema para Estilização
theme_minimal() +
theme(
legend.position = "none", # A legenda de cor é redundante com a barra
plot.title = element_text(face = "bold", hjust = 0.5),
strip.text = element_text(face = "bold", size = 11) # Títulos dos Facets
)
modelo_tl <- lm(df_z$Topload ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$`ICC (Expectativas)` + df_z$Sazonalidade)
# Resumo
summary(modelo_tl)
# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_tl)
modelo_tl_2 <- lm(df_z$Topload ~ df_z$Selic + df_z$IPP + df_z$`ICC (Expectativas)` + df_z$Sazonalidade)
# Resumo
summary(modelo_tl_2)
# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_tl_2)
modelo_fg <- lm(df_z$Fogão ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$ICC + df_z$Sazonalidade)
# Resumo
summary(modelo_fg)
# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_fg)
modelo_fg_2 <- lm(df_z$Fogão ~ df_z$IPP + df_z$`Massa Salarial`)
# Resumo
summary(modelo_fg_2)
# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_fg_2)
modelo_tf <- lm(df_z$Topfreezer ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$ICC + df_z$Sazonalidade)
# Resumo
summary(modelo_tf)
# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_tf)
modelo_tf_2 <- lm(df_z$Topfreezer ~ df_z$Selic + df_z$IPP)
# Resumo
summary(modelo_tf_2)
# Diagnóstico gráfico
par(mfrow = c(2, 2))
plot(modelo_tf_2)
library(dplyr)
library(tidyr)
library(ggplot2)
library(purrr)
library(patchwork) # Para combinar múltiplos gráficos ggplot2
# --- 1. Preparação dos Dados (Split Treino/Teste) ---
set.seed(123)
n <- nrow(df_z)
indices_treino <- sample(1:n, size = round(2/3 * n))
treino <- df_z[indices_treino, ]
teste <- df_z[-indices_treino, ]
# --- 2. Definição dos Modelos a serem Avaliados ---
# Use uma lista nomeada para mapear cada variável dependente à sua fórmula final.
# Os modelos escolhidos são os 'modelo_X_2' ou equivalentes do seu script.
modelos_a_avaliar <- list(
Topload = Topload ~ Selic + IPP + `ICC (Expectativas)` + Sazonalidade,
Fogao = Fogão ~ IPP + `Massa Salarial`,
Topfreezer = Topfreezer ~ Selic + IPP
)
# --- 3. Função de Validação e Cálculo de Métricas (Core da Otimização) ---
validar_modelo <- function(formula, nome_modelo, dados_treino, dados_teste) {
# 1. Treinar o modelo
modelo_fit <- lm(formula, data = dados_treino)
# 2. Prever nos dados de teste
preds <- predict(modelo_fit, newdata = dados_teste)
# Variável Real (Y)
y_real <- dados_teste[[gsub(" .*", "", as.character(formula)[2])]] # Extrai o nome da variável dependente da fórmula
# 3. Calcular Métricas
RMSE <- sqrt(mean((y_real - preds)^2, na.rm = TRUE))
MAE <- mean(abs(y_real - preds), na.rm = TRUE)
SS_res <- sum((y_real - preds)^2, na.rm = TRUE)
SS_tot <- sum((y_real - mean(y_real, na.rm = TRUE))^2, na.rm = TRUE)
R2 <- 1 - (SS_res / SS_tot)
# 4. Retornar um dataframe com as métricas e os dados para o gráfico
return(list(
# Tabela de Métricas
metrics = data.frame(
Modelo = nome_modelo,
RMSE = RMSE,
MAE = MAE,
R2 = R2
),
# Dados para o Gráfico Predito vs Real
plot_data = data.frame(
Modelo = nome_modelo,
Real = y_real,
Predito = preds
)
))
}
# --- 4. Executar a Validação Cruzada para todos os Modelos (Iteração) ---
# Usar 'map' para aplicar a função a cada modelo na lista
resultados_lista <- map(
names(modelos_a_avaliar),
~ validar_modelo(
formula = modelos_a_avaliar[[.x]],
nome_modelo = .x,
dados_treino = treino,
dados_teste = teste
)
)
# --- 5. Consolidar os Outputs ---
# Reunir as tabelas de métricas em um dataframe único
tabela_metricas <- map_dfr(resultados_lista, "metrics")
# Reunir os dados de plotagem para um gráfico facetado
df_plot_final <- map_dfr(resultados_lista, "plot_data")
# ----------------------------------------------------------------------
# -------------------- OTIMIZAÇÃO DA VISUALIZAÇÃO ----------------------
# ----------------------------------------------------------------------
## 1. TABELA DE MÉTRICAS CONSOLIDADAS
cat("=========================================================\n")
cat("          METRICAS DE PERFORMANCE EM DADOS DE TESTE       \n")
cat("=========================================================\n")
print(tabela_metricas %>%
mutate(across(c(RMSE, MAE, R2), ~ round(.x, 4))) # Formatar para 4 casas decimais
)
cat("\n\n")
## 2. GRÁFICO DE PREDITO VS. REAL UNIFICADO
# Criar o gráfico base usando facet_wrap para os 3 modelos
grafico_final_cv <- ggplot(df_plot_final, aes(x = Real, y = Predito)) +
# Pontos
geom_point(aes(color = Modelo), alpha = 0.7) +
# Linha de tendência (opcional, mostra o ajuste do modelo)
geom_smooth(method = "lm", se = FALSE, color = "blue", linewidth = 0.5) +
# Dividir o gráfico em 3 painéis (facets)
facet_wrap(~ Modelo, scales = "free", ncol = 3) +
# Adicionar o R² como anotação em cada painel
geom_text(
data = tabela_metricas,
aes(
label = paste0("R² = ", round(R2, 4)),
x = Inf, # Posição no canto superior direito do eixo X
y = -Inf # Posição no canto superior direito do eixo Y (inverso para topo)
),
hjust = 1.1, vjust = -1, # Ajustar posição para dentro da área de plotagem
size = 4, fontface = "bold", color = "darkgreen"
) +
# Títulos e Tema
labs(
title = "Valores Reais vs. Preditos (Validação Cruzada)",
subtitle = "Linha pontilhada vermelha é a linha de ajuste perfeito (Real = Predito)",
x = "Valor Real (Unidade)",
y = "Valor Predito (Unidade)"
) +
theme_bw() +
theme(
plot.title = element_text(face = "bold", hjust = 0.5),
strip.text = element_text(face = "bold", size = 10), # Títulos dos Facets (Topload, Fogão, Topfreezer)
legend.position = "none"
)
# Exibir o gráfico final
print(grafico_final_cv)
#Criação de um modelo preliminar com as variáveis mais correlacionadas
modelo_vif_tl <- lm(df_z$Topload ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$`ICC (Expectativas)` + df_z$Sazonalidade)
modelo_vif_fg <- lm(df_z$Fogão ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$ICC + df_z$Sazonalidade)
modelo_vif_tf <- lm(df_z$Topfreezer ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$ICC + df_z$Sazonalidade)
# --- 2. Calcular VIFs e Consolidar os Dados ---
# Função auxiliar para calcular VIF e formatar em um dataframe
calcular_vif_df <- function(modelo, nome_dependente) {
vif_valores <- car::vif(modelo)
# Cria um dataframe com os resultados
df_resultado <- data.frame(
Variavel_Dependente = nome_dependente,
Variavel_Independente = names(vif_valores),
VIF = as.numeric(vif_valores)
)
return(df_resultado)
}
# Calcular e combinar os VIFs de todos os modelos
df_vif_final <- bind_rows(
calcular_vif_df(modelo_vif_tl, "Topload"),
calcular_vif_df(modelo_vif_fg, "Fogão"),
calcular_vif_df(modelo_vif_tf, "Topfreezer")
)
# --- 3. Criar a Visualização com ggplot2 ---
# Definir o limite de VIF (o valor 5 é um limite comum de atenção)
VIF_LIMITE <- 5
ggplot(df_vif_final, aes(x = VIF, y = Variavel_Independente, fill = VIF)) +
# Gráfico de Barras Horizontal
geom_bar(stat = "identity") +
# Linha de Referência para o limite de multicolinearidade (VIF > 5)
geom_vline(
xintercept = VIF_LIMITE,
linetype = "dashed",
color = "red",
size = 1
) +
# Texto no gráfico para indicar a linha de limite
annotate("text",
x = VIF_LIMITE + 0.5, y = Inf,
color = "red",
hjust = 0, vjust = 1.5,
size = 3.5, fontface = "bold") +
# Escala de Cor (para colorir as barras com base no valor VIF)
scale_fill_gradient(low = "#2ECC71", high = "#E74C3C", # Verde para baixo, Vermelho para alto
limits = c(0, max(c(df_vif_final$VIF, VIF_LIMITE)))) +
# Dividir em painéis (facetas) por Variável Dependente
facet_wrap(~ Variavel_Dependente, ncol = 3, scales = "free_y") +
# Títulos e Rótulos
labs(
title = "Análise de Multicolinearidade (VIF) por Variável Dependente",
subtitle = "Linha pontilhada vermelha indica VIF = 5 (limite de atenção)",
x = "Valor do VIF (Variance Inflation Factor)",
y = "Variável Independente",
fill = "VIF"
) +
# Tema para Estilização
theme_minimal() +
theme(
legend.position = "none", # A legenda de cor é redundante com a barra
plot.title = element_text(face = "bold", hjust = 0.5),
strip.text = element_text(face = "bold", size = 11) # Títulos dos Facets
)
#Criação de um modelo preliminar com as variáveis mais correlacionadas
modelo_vif_tl <- lm(df_z$Topload ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$`ICC (Expectativas)` + df_z$Sazonalidade)
modelo_vif_fg <- lm(df_z$Fogão ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$ICC + df_z$Sazonalidade)
modelo_vif_tf <- lm(df_z$Topfreezer ~ df_z$Selic + df_z$IPP + df_z$`Massa Salarial` + df_z$ICC + df_z$Sazonalidade)
# --- 2. Calcular VIFs e Consolidar os Dados ---
# Função auxiliar para calcular VIF e formatar em um dataframe
calcular_vif_df <- function(modelo, nome_dependente) {
vif_valores <- car::vif(modelo)
# Cria um dataframe com os resultados
df_resultado <- data.frame(
Variavel_Dependente = nome_dependente,
Variavel_Independente = names(vif_valores),
VIF = as.numeric(vif_valores)
)
return(df_resultado)
}
# Calcular e combinar os VIFs de todos os modelos
df_vif_final <- bind_rows(
calcular_vif_df(modelo_vif_tl, "Topload"),
calcular_vif_df(modelo_vif_fg, "Fogão"),
calcular_vif_df(modelo_vif_tf, "Topfreezer")
)
# --- 3. Criar a Visualização com ggplot2 ---
# Definir o limite de VIF (o valor 5 é um limite comum de atenção)
VIF_LIMITE <- 5
ggplot(df_vif_final, aes(x = VIF, y = Variavel_Independente, fill = VIF)) +
# Gráfico de Barras Horizontal
geom_bar(stat = "identity") +
# Linha de Referência para o limite de multicolinearidade (VIF > 5)
geom_vline(
xintercept = VIF_LIMITE,
linetype = "dashed",
color = "red",
size = 1
) +
# Texto no gráfico para indicar a linha de limite
annotate("text",
x = VIF_LIMITE + 0.5, y = Inf,
label = "",
color = "red",
hjust = 0, vjust = 1.5,
size = 3.5, fontface = "bold") +
# Escala de Cor (para colorir as barras com base no valor VIF)
scale_fill_gradient(low = "#2ECC71", high = "#E74C3C", # Verde para baixo, Vermelho para alto
limits = c(0, max(c(df_vif_final$VIF, VIF_LIMITE)))) +
# Dividir em painéis (facetas) por Variável Dependente
facet_wrap(~ Variavel_Dependente, ncol = 3, scales = "free_y") +
# Títulos e Rótulos
labs(
title = "Análise de Multicolinearidade (VIF) por Variável Dependente",
subtitle = "Linha pontilhada vermelha indica VIF = 5 (limite de atenção)",
x = "Valor do VIF (Variance Inflation Factor)",
y = "Variável Independente",
fill = "VIF"
) +
# Tema para Estilização
theme_minimal() +
theme(
legend.position = "none", # A legenda de cor é redundante com a barra
plot.title = element_text(face = "bold", hjust = 0.5),
strip.text = element_text(face = "bold", size = 11) # Títulos dos Facets
)
